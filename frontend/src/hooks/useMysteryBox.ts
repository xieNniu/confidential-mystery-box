import { useState, useCallback, useEffect } from 'react';
import { ethers } from 'ethers';
import { useContractInteraction } from './useContract';
import { encryptNumber } from '../utils/fhevm';
import { formatEth, parseEth, generatePrizePool, getRandomPrizeAmount, waitForTransaction } from '../utils/helpers';
import { BoxSeries, UserBox } from '../types';
import RelayerClient from '../utils/relayerClient';

export function useMysteryBox() {
  const { getContractInstance, getContractAddress, contractType, userAddress } =
    useContractInteraction();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [series, setSeries] = useState<BoxSeries[]>([]);
  const [boxes, setBoxes] = useState<UserBox[]>([]);

  /**
   * Get all series
   */
  const getAllSeries = useCallback(async (): Promise<BoxSeries[]> => {
    try {
      const contract = await getContractInstance();
      const totalSeries = await contract.getTotalSeries();
      const seriesCount = Number(totalSeries);

      const seriesList: BoxSeries[] = [];

      for (let i = 1; i <= seriesCount; i++) {
        const info = await contract.getSeriesInfo(i);
        seriesList.push({
          id: Number(info[0]),
          name: info[1],
          price: formatEth(info[2]),
          totalBoxes: Number(info[3]),
          remainingBoxes: Number(info[4]),
          creator: info[5],
          isActive: info[6],
        });
      }

      return seriesList;
    } catch (err: any) {
      console.error('‚ùå Ëé∑ÂèñÁ≥ªÂàóÂ§±Ë¥•:', err);
      throw err;
    }
  }, [getContractInstance]);

  /**
   * Get user's boxes
   */
  const getUserBoxes = useCallback(async (): Promise<UserBox[]> => {
    if (!userAddress) {
      throw new Error('ËØ∑ÂÖàËøûÊé•Èí±ÂåÖ');
    }

    try {
      const contract = await getContractInstance();
      const boxIds = await contract.getUserBoxIds(userAddress);

      const boxes: UserBox[] = [];

      for (const boxId of boxIds) {
        const info = await contract.getBoxInfo(boxId);
        
        if (contractType === 'fhe') {
          // FHE mode - new format with status enum
          // Returns: boxId, seriesId, boxOwner, status, revealedPrizeAmount, purchaseTime, expiresAt
          const status = Number(info[3]); // BoxStatus enum: 0=PURCHASED, 1=PENDING_DECRYPT, 2=DECRYPTING, 3=OPENED, 4=PRIZE_WITHDRAWN, 5=EXPIRED
          
          boxes.push({
            boxId: Number(info[0]),
            seriesId: Number(info[1]),
            owner: info[2],
            isOpened: status === 3 || status === 4, // OPENED or PRIZE_WITHDRAWN
            isDecrypting: status === 1 || status === 2, // PENDING_DECRYPT or DECRYPTING
            revealedPrizeAmount: info[4] ? formatEth(info[4]) : undefined,
            purchaseTime: Number(info[5]),
          });
        } else {
          // Simple mode - old format (still compatible)
          boxes.push({
            boxId: Number(info[0]),
            seriesId: Number(info[1]),
            owner: info[2],
            prizeAmount: formatEth(info[3]),
            isOpened: info[4],
            purchaseTime: Number(info[5]),
          });
        }
      }

      return boxes;
    } catch (err: any) {
      console.error('‚ùå Ëé∑ÂèñÁî®Êà∑Áõ≤ÁõíÂ§±Ë¥•:', err);
      throw err;
    }
  }, [getContractInstance, userAddress, contractType]);

  /**
   * Create series (Admin only)
   */
  const createSeries = useCallback(
    async (
      name: string,
      price: string,
      totalBoxes: number
    ): Promise<void> => {
      setLoading(true);
      setError(null);

      try {
        const contract = await getContractInstance();
        const priceWei = parseEth(price);

        if (contractType === 'fhe') {
          // FHE mode - no prize amounts needed upfront
          const tx = await contract.createSeries(name, priceWei, totalBoxes);
          await waitForTransaction(tx);
        } else {
          // Simple mode - generate prize amounts
          const prizeAmounts = generatePrizePool(totalBoxes, priceWei);
          const tx = await contract.createSeries(name, priceWei, totalBoxes, prizeAmounts);
          await waitForTransaction(tx);
        }

        console.log('‚úÖ Á≥ªÂàóÂàõÂª∫ÊàêÂäü');
      } catch (err: any) {
        console.error('‚ùå ÂàõÂª∫Á≥ªÂàóÂ§±Ë¥•:', err);
        setError(err.message || 'ÂàõÂª∫Â§±Ë¥•');
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [getContractInstance, contractType]
  );

  /**
   * Purchase box
   */
  const purchaseBox = useCallback(
    async (seriesId: number, price: string): Promise<void> => {
      setLoading(true);
      setError(null);

      try {
        const contract = await getContractInstance();
        const priceWei = parseEth(price);

        if (contractType === 'fhe') {
          // FHE mode - encrypt prize amount
          if (!userAddress) throw new Error('ËØ∑ÂÖàËøûÊé•Èí±ÂåÖ');
          
          const contractAddress = getContractAddress();
          const prizeAmount = getRandomPrizeAmount(priceWei);
          
          const { handle, proof } = await encryptNumber(
            Number(prizeAmount),
            contractAddress,
            userAddress
          );

          const tx = await contract.purchaseBox(seriesId, handle, proof, {
            value: priceWei,
          });
          await waitForTransaction(tx);
        } else {
          // Simple mode - pass prize amount
          const prizeAmount = getRandomPrizeAmount(priceWei);
          
          const tx = await contract.purchaseBox(seriesId, prizeAmount, {
            value: priceWei,
          });
          await waitForTransaction(tx);
        }

        console.log('‚úÖ Ë¥≠‰π∞ÊàêÂäü');
      } catch (err: any) {
        console.error('‚ùå Ë¥≠‰π∞Â§±Ë¥•:', err);
        setError(err.message || 'Ë¥≠‰π∞Â§±Ë¥•');
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [getContractInstance, contractType, userAddress, getContractAddress]
  );

  /**
   * Open box - Complete decryption flow (5 steps)
   * Follows FHEVM Development Standards Section 3.4
   */
  const openBox = useCallback(
    async (
      boxId: number,
      onProgress?: (progress: number, message: string) => void
    ): Promise<void> => {
      setLoading(true);
      setError(null);

      try {
        const contract = await getContractInstance();
        const contractAddress = getContractAddress();

        if (contractType === 'fhe') {
          // ===== Step 1: Submit on-chain decryption request =====
          if (onProgress) onProgress(10, 'Submitting decryption request...');
          console.log('üéÆ ÂºÄÂßãËß£ÂØÜÁõ≤Áõí:', boxId);
          
          const tx = await contract.openBox(boxId);
          console.log('üìù ‰∫§ÊòìÂ∑≤Êèê‰∫§:', tx.hash);
          
          if (onProgress) onProgress(20, 'Waiting for transaction confirmation...');
          const receipt = await waitForTransaction(tx);
          console.log('‚úÖ ‰∫§ÊòìÂ∑≤Á°ÆËÆ§');

          // ===== Step 2: Get requestId from event =====
          if (onProgress) onProgress(30, 'Extracting request ID from event...');
          
          const event = receipt.logs.find((log: any) => {
            try {
              const parsed = contract.interface.parseLog({
                topics: log.topics || [],
                data: log.data || '',
              });
              return parsed && (parsed.name === 'DecryptionRequested' || parsed.name === 'BoxOpenRequested');
            } catch {
              return false;
            }
          });

          if (!event) {
            throw new Error('Êú™ÊâæÂà∞ DecryptionRequested ‰∫ã‰ª∂');
          }

          const parsedEvent = contract.interface.parseLog({
            topics: event.topics || [],
            data: event.data || '',
          });

          const requestId = parsedEvent?.args?.requestId || parsedEvent?.args?.[2];
          if (!requestId) {
            throw new Error('Êú™ÊâæÂà∞ requestId');
          }

          console.log('üîë Ëß£ÂØÜËØ∑Ê±ÇID:', requestId.toString());

          // ===== Step 3: Poll Gateway (ÂÖ≥ÈîÆÊ≠•È™§) =====
          if (onProgress) onProgress(40, 'Polling Gateway for decryption...');
          console.log('‚è≥ ÂºÄÂßãËΩÆËØ¢ Gateway...');

          const relayerClient = new RelayerClient('sepolia');
          const pollResult = await relayerClient.pollDecryption(
            requestId,
            contractAddress,
            {
              onProgress: (pollProgress) => {
                const percentage = 40 + (pollProgress.percentage * 0.3);
                if (onProgress) {
                  onProgress(
                    Math.round(percentage),
                    `Polling Gateway... ${pollProgress.percentage}% (${pollProgress.current}/${pollProgress.total})`
                  );
                }
              },
            }
          );

          if (!pollResult.success) {
            throw new Error(pollResult.error || 'Gateway decryption timeout');
          }

          console.log('‚úÖ Gateway Ëß£ÂØÜÂÆåÊàê');

          // ===== Step 4: Wait for on-chain callback completion =====
          if (onProgress) onProgress(85, 'Waiting for on-chain callback...');
          console.log('‚è≥ Á≠âÂæÖÈìæ‰∏äÂõûË∞É...');

          await waitForCallbackCompletion(boxId, contract, (waitProgress) => {
            const percentage = 85 + (waitProgress * 0.1);
            if (onProgress) {
              onProgress(Math.round(percentage), 'Waiting for callback...');
            }
          });

          // ===== Step 5: Get final result =====
          if (onProgress) onProgress(95, 'Getting final result...');
          const boxInfo = await contract.getBoxInfo(boxId);
          console.log('üéâ Ëß£ÂØÜÊµÅÁ®ãÂÆåÊàê!', boxInfo);

          if (onProgress) onProgress(100, 'Decryption completed!');
        } else {
          // Simple mode - direct open
          const tx = await contract.openBox(boxId);
          await waitForTransaction(tx);
          console.log('‚úÖ Áõ≤ÁõíÂ∑≤ÂºÄÂêØ');
        }
      } catch (err: any) {
        console.error('‚ùå ÂºÄÁõíÂ§±Ë¥•:', err);
        setError(err.message || 'ÂºÄÁõíÂ§±Ë¥•');
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [getContractInstance, contractType, getContractAddress]
  );

  /**
   * Wait for on-chain callback completion
   */
  const waitForCallbackCompletion = async (
    boxId: number,
    contract: ethers.Contract,
    onProgress: (progress: number) => void
  ): Promise<void> => {
    const MAX_WAIT = 120; // 2ÂàÜÈíü
    const INTERVAL = 2000; // 2Áßí

    for (let i = 0; i < MAX_WAIT; i++) {
      onProgress(i / MAX_WAIT);

      try {
        const boxInfo = await contract.getBoxInfo(boxId);
        // status: 3 = OPENED (BoxStatus enum)
        if (boxInfo[3] === 3) {
          console.log('‚úÖ ÂõûË∞ÉÂ∑≤Âú®Èìæ‰∏äÂÆåÊàê');
          return;
        }
      } catch (error) {
        console.warn('‚è≥ Á≠âÂæÖÂõûË∞É‰∏≠...', error);
      }

      await new Promise((resolve) => setTimeout(resolve, INTERVAL));
    }

    throw new Error('Á≠âÂæÖÂõûË∞ÉË∂ÖÊó∂ - ËØ∑Ê£ÄÊü•ÂêàÁ∫¶Áä∂ÊÄÅÊàñÈáçËØï');
  };

  /**
   * Withdraw prize
   */
  const withdrawPrize = useCallback(
    async (boxId: number): Promise<void> => {
      setLoading(true);
      setError(null);

      try {
        const contract = await getContractInstance();
        const tx = await contract.withdrawPrize(boxId);
        await waitForTransaction(tx);

        console.log('‚úÖ Â•ñÂìÅÂ∑≤È¢ÜÂèñ');
      } catch (err: any) {
        console.error('‚ùå È¢ÜÂèñÂ§±Ë¥•:', err);
        setError(err.message || 'È¢ÜÂèñÂ§±Ë¥•');
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [getContractInstance]
  );

  /**
   * Deposit prize fund (Admin only)
   */
  const depositPrizeFund = useCallback(
    async (amount: string): Promise<void> => {
      setLoading(true);
      setError(null);

      try {
        const contract = await getContractInstance();
        const amountWei = parseEth(amount);
        const tx = await contract.depositPrizeFund({ value: amountWei });
        await waitForTransaction(tx);

        console.log('‚úÖ ÂÖÖÂÄºÊàêÂäü');
      } catch (err: any) {
        console.error('‚ùå ÂÖÖÂÄºÂ§±Ë¥•:', err);
        setError(err.message || 'ÂÖÖÂÄºÂ§±Ë¥•');
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [getContractInstance]
  );

  /**
   * Get contract balance
   */
  const getContractBalance = useCallback(async (): Promise<string> => {
    try {
      const contract = await getContractInstance();
      const balance = await contract.getContractBalance();
      return formatEth(balance);
    } catch (err: any) {
      console.error('‚ùå Ëé∑Âèñ‰ΩôÈ¢ùÂ§±Ë¥•:', err);
      throw err;
    }
  }, [getContractInstance]);

  /**
   * Get contract owner
   */
  const getContractOwner = useCallback(async (): Promise<string> => {
    try {
      const contract = await getContractInstance();
      const ownerAddress = await contract.owner();
      return ownerAddress.toLowerCase();
    } catch (err: any) {
      console.error('‚ùå Ëé∑Âèñ owner Â§±Ë¥•:', err);
      throw err;
    }
  }, [getContractInstance]);

  /**
   * Refresh series data
   */
  const refreshSeries = useCallback(async () => {
    try {
      console.log('üîÑ Âà∑Êñ∞Á≥ªÂàóÊï∞ÊçÆ...');
      setLoading(true);
      const data = await getAllSeries();
      setSeries(data);
      console.log('‚úÖ Á≥ªÂàóÊï∞ÊçÆÂ∑≤Êõ¥Êñ∞:', data);
    } catch (err: any) {
      console.error('‚ùå Âà∑Êñ∞Â§±Ë¥•:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [getAllSeries]);

  /**
   * Refresh user boxes
   */
  const refreshBoxes = useCallback(async () => {
    if (!userAddress) return;
    
    try {
      console.log('üîÑ Âà∑Êñ∞Áî®Êà∑Áõ≤Áõí...');
      const data = await getUserBoxes();
      setBoxes(data);
      console.log('‚úÖ Áî®Êà∑Áõ≤ÁõíÂ∑≤Êõ¥Êñ∞:', data);
    } catch (err: any) {
      console.error('‚ùå Âà∑Êñ∞Â§±Ë¥•:', err);
    }
  }, [getUserBoxes, userAddress]);

  /**
   * Auto-load data on mount and when contract changes
   */
  useEffect(() => {
    let mounted = true;
    
    const loadData = async () => {
      try {
        console.log('üîÑ Ëá™Âä®Âä†ËΩΩÁ≥ªÂàóÊï∞ÊçÆ...');
        setLoading(true);
        const contract = await getContractInstance();
        const totalSeries = await contract.getTotalSeries();
        const seriesCount = Number(totalSeries);

        const seriesList: BoxSeries[] = [];

        for (let i = 1; i <= seriesCount; i++) {
          const info = await contract.getSeriesInfo(i);
          seriesList.push({
            id: Number(info[0]),
            name: info[1],
            price: formatEth(info[2]),
            totalBoxes: Number(info[3]),
            remainingBoxes: Number(info[4]),
            creator: info[5],
            isActive: info[6],
          });
        }

        if (mounted) {
          setSeries(seriesList);
          console.log('‚úÖ Á≥ªÂàóÊï∞ÊçÆÂä†ËΩΩÂÆåÊàê:', seriesList);
        }
      } catch (err: any) {
        console.error('‚ùå Ëá™Âä®Âä†ËΩΩÂ§±Ë¥•:', err);
        if (mounted) {
          setError(err.message);
          setSeries([]);
        }
      } finally {
        if (mounted) {
          setLoading(false);
        }
      }
    };
    
    loadData();
    
    return () => {
      mounted = false;
    };
  }, [contractType]);

  useEffect(() => {
    let mounted = true;
    
    const loadBoxes = async () => {
      if (!userAddress) {
        if (mounted) {
          setBoxes([]);
        }
        return;
      }
      
      try {
        console.log('üîÑ Ëá™Âä®Âä†ËΩΩÁî®Êà∑Áõ≤Áõí...');
        const contract = await getContractInstance();
        const boxIds = await contract.getUserBoxIds(userAddress);

        const boxesList: UserBox[] = [];

        for (const boxId of boxIds) {
          const info = await contract.getBoxInfo(boxId);
          
          if (contractType === 'fhe') {
            // FHE mode
            boxesList.push({
              boxId: Number(info[0]),
              seriesId: Number(info[1]),
              owner: info[2],
              isOpened: info[3],
              isDecrypting: info[4],
              revealedPrizeAmount: info[5] ? formatEth(info[5]) : undefined,
              purchaseTime: Number(info[6]),
            });
          } else {
            // Simple mode
            boxesList.push({
              boxId: Number(info[0]),
              seriesId: Number(info[1]),
              owner: info[2],
              prizeAmount: formatEth(info[3]),
              isOpened: info[4],
              purchaseTime: Number(info[5]),
            });
          }
        }

        if (mounted) {
          setBoxes(boxesList);
          console.log('‚úÖ Áî®Êà∑Áõ≤ÁõíÂä†ËΩΩÂÆåÊàê:', boxesList);
        }
      } catch (err: any) {
        console.error('‚ùå Ëá™Âä®Âä†ËΩΩÁõ≤ÁõíÂ§±Ë¥•:', err);
        if (mounted) {
          setBoxes([]);
        }
      }
    };
    
    loadBoxes();
    
    return () => {
      mounted = false;
    };
  }, [userAddress, contractType]);

  return {
    loading,
    error,
    series,
    boxes,
    getAllSeries,
    getUserBoxes,
    createSeries,
    purchaseBox,
    openBox,
    withdrawPrize,
    depositPrizeFund,
    getContractBalance,
    getContractOwner,
    refreshSeries,
    refreshBoxes,
  };
}

